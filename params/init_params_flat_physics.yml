# Group by physics / code logic
init_params : {
    # Measurements
    'meas_source'            : 'raw', # type: str. Data type of the measurements (diffraction patterns). Currently supporting 'raw', 'hdf5', 'mat', 'tif', and 'custom'. 
    'meas_params'            : {'path': 'data/tBL_WSe2/Panel_g-h_Themis/scan_x128_y128.raw'}, # type: dict, or numpy array. For 'measurements_source' = 'mat', or 'hdf5', provide the 'path' and 'key' in a dict {'path': <PATH_TO_DATA>, 'key': <DATA_KEY>} to retrieve the data matrix. 'tif' would only need the {'path':<PATH_TO_DATA>}. For 'raw' you can optionally pass in 'shape':(N,height,width), 'offset':int, 'gap':int to load the .raw files from EMPAD1 and pre-processed EMPAD datasets. For example, {'path': <PATH_TO_DATA>, 'offset':0, 'gap':0} can be used to load pre-processed EMPAD2 raw dataset with no gap between binary diffraction patterns. The 'shape' will be automatically filled in from 'exp_params', while 'offset':0, and 'gap':1024 are default values for EMPAD1 datasets. For py4dstem processed diffraction patterns (hdf5), use '/datacube_root/datacube/data' for your 'key'. For 'custom' source, pass the numpy array to the 'measurements_params' entry after you load this .yml as a dict
    'meas_Npix'              : 128, # type: integer, unit: px (k-space). Detector pixel number, EMPAD is 128. Only supports square detector for simplicity
    'meas_permute'           : null, # type: null or list of ints. This applies additional permutation (reorder axes) for the initialized diffraction patterns. The syntax is the same as np.transpose()
    'meas_reshape'           : null, # type: null or list of 3 ints. This applies additional reshaping (rearrange elements) for the initialized diffraction patterns. The syntax is the same as np.reshape(). This is commonly needed to convert the 4D diffraction dataset (Ry,Rx,ky,kx) into 3D (N_scans,ky,kx)
    'meas_flipT'             : [1,0,0], # type: null or list of 3 binary booleans (0 or 1) as [flipup, fliplr, transpose] just like PtychoShleves. Default is null or [0,0,0] but you may need to find the correct flip and transpose to match your dataset configuration. This applies additional flip and transpose to initialized diffraction patterns. It's suggested to use 'meas_flipT' to correct the dataset orientation and this is the only orientaiton-related value attached to output reconstruction folder name
    'meas_crop'              : null, # type: null or (4,2) nested list of ints as [[scan_slow_start, scan_slow_end], [scan_fast_start, scan_fast_end], [ky_start, ky_end], [kx_start, kx_end]]. This applies additional cropping to the 4D dataset in both real and k-space. This is useful for reconstrucing a subset of real-space probe positions, or to crop the kMax of diffraction patterns. The syntax follows conventional numpy indexing so the upper bound is not included
    'meas_pad'               : {'mode': null, 'padding_type': 'power', 'target_Npix': 256,'value': 0}, # type: dict. 'mode' can be 'on_the_fly', 'precompute', or null. 'padding_type' can be 'constant', 'edge', 'linear_ramp', 'exp', or 'power'. This will pad the CBED to side length = 'target_Npix' based on the padding_type. If using 'exp' or 'power', the mean diffraction pattern amplitude is used to fit the functional coefficients. 'precompute' will pad the measurements during initialization, while 'on_the_fly' will only pad the measurements during optimization, so it's more efficient for GPU memory. 'on_the_fly' padding doesn't really affect the reconstruction time so it's suggested to always use 'on_the_fly' if you're padding to save the GPU memory.
    'meas_resample'          : {'mode': null, 'scale_factors': [2,2]}, # type: dict. 'mode' can be 'on_the_fly', 'precompute', or null. 'scale_factor' takes a list of 2 floats as [ky_zoom, kx_zoom]. This applies additional resampling of initialized diffraction patterns along ky and kx directions. This is useful for changing the k-space sampling of diffraction patterns. See scipy.ndimage.zoom for more details.'precompute' will resample the measurements during initialization, while 'on_the_fly' will only resample the measurements during optimization, so it's more efficient for GPU memory if you're upsampling (i.e., scale_factor > 1). For downsampling, it's much better to do 'precompute' to save GPU memory. 'on_the_fly' resampling doesn't really affect the reconstruction time so it's suggested to always use 'on_the_fly' if you're upsampling.
    'meas_add_source_size'   : null, # type: null or float, unit: Ang. This adds additional spatial partial coherence to diffraction patterns by applying Gaussian blur along scan directions. The provided value is used as the std (sigma) for the Gaussian blurring kernel in real space. Note that FWHM ~ 2.355 std, so a std of 0.34 Ang is equivalent to a source size (FWHM) of 0.8 Ang
    'meas_add_detector_blur' : null, # type: null or float, unit: px (k-space). This adds additional detector blur to diffraction patterns to emulate the PSF on detector. The provided value is used as the std (sigma) for the Gaussian blurring kernel in k-space. Note that this is applied to the "measured", or "ground truth" diffraction pattern and is different from 'model_params['detector_blur_std']' that applies to the forward simulated diffraction pattern
    'meas_remove_neg_values' : {'mode': 'clip_neg', 'value': null}, # type: dict. Choose the preprocessing method for handling negative values in the measurements. Available options are 'subtract_min', 'subtract_value', 'clip_neg', and 'clip_value'. Previously (before beta3.1) the PtyRAD default is 'subtract_min', while for low dose data is recommended to use 'clip_neg' or 'clip_value' i.e. {'mode': 'clip_neg', 'value': 20}. Current default is 'clip_neg'.
    'meas_add_poisson_noise' : null, # type: null or dict, i.e., {'unit': 'total_e_per_pattern', 'value': 10000} or {'unit': 'e_per_Ang2', 'value': 10000}. This applies additional Poisson noise to diffraction patterns to emulate the Poisson statistics of electron dose based on the given unit, value, and scan step size. This is useful when you have a noise-free simulated dataset and want to try ptychographic reconstruciton at different dose conditions
    # Probe
    'probe_source'           : 'simu', # type: str. Data source of the probe. Currently supporting 'simu', 'PtyRAD', 'PtyShv', and 'custom'
    'probe_params'           : null, # type: null, dict, str, or numpy array. Parameters of the probe loading/initialization. For 'simu' (simulating probe), provide a dict of 'probe_simu_params' to specify the simulation parameters (see 'utils/make_stem_probe' for more details) or null to use only basic paramaters like kV, conv_angle, defocus and c3. For loading probe from 'PtyRAD' or 'PtyShv', provide a str of <PATH_TO_RECONSTRUCTION_FILE>. For 'custom' probe source, pass the 3D numpy array to the 'probe_params' entry after you load this .yml as a dict
    'probe_illum_type'       : 'electron', # type: str. Choose between 'electron' or 'xray'
    'probe_kv'               : 80, # type: float, unit: kV. Acceleration voltage for relativistic electron wavelength calculation
    'probe_dx_spec'          : 0.1494, # type: float, unit: Ang. Real space pixel size calibration at specimen plane (object, probe, and probe positions share the same pixel size)
    'probe_conv_angle'       : 24.9, # type: float, unit: mrad. Semi-convergence angle for probe-forming aperture
    'probe_defocus'          : 0, # type: float, unit: Ang. Defocus (-C1) aberration coefficient for the probe. Positive defocus here refers to actual underfocus or weaker lens strength following Kirkland/abtem/ptychoshelves convention
    'probe_c3'               : 0, # type: float, unit: Ang. 3rd-order spherical aberration coefficient (C3) for the simulated probe
    'probe_c5'               : 0, # type: float, unit: Ang. 5th-order spherical aberration coefficient (C5) for the simulated probe
    'probe_pmode_max'        : 6, # type: int, unit: #. Maximum number of mixed probe modes. Set to pmode_max = 1 for single probe state, pmode_max > 1 for mixed-state probe during initialization. For simulated initial object, it'll be generated with the specified number of probe modes. For loaded probe, the pmode dimension would be capped at this number
    'probe_pmode_init_pows'  : [0.02], # type: list of 1 or a few (pmode_max) floats. Initial power for each additional probe modes. If set at [0.02], all additional probe modes would contain 2% of the total intensity. sum(pmode_init_pows) must be 1 if more than len(pmode_init_pows) > 1. See 'utils.make_mixed_probe' for more details
    'probe_permute'          : null, # type: null or list of int. This applies additional permutation (reorder axes) for the initialized probe. The syntax is the same as np.transpose()
    # Scan position
    'pos_source'             : 'simu', # type: str. Data source of the probe positions. Currently supporting 'simu', 'PtyRAD', 'PtyShv', 'foldslice_hdf5', and 'custom'
    'pos_params'             : null, # type: null, str, or numpy array. Parameters of the probe positions loading/initialization. For 'simu' (simulating probe positions), provide null and check whether you need 'scan_flipT'. The positions would be simulated based on 'N_scan_slow', 'N_scan_fast', 'scan_step_size', and 'scan_affine'. For loading probe positions from 'PtyRAD' or 'PtyShv', provide a str of <PATH_TO_RECONSTRUCTION_FILE>. For loading probe positions from 'foldslice_hdf5', provide a str of <PATH_TO_POSITION_FILE>. These hdf5 files are generated from many APS instruments that were previously handled in `fold_slice` using 'p.src_positions='hdf5_pos'. For 'custom' probe position source, pass the (N_scans,2) numpy array to the 'pos_params' entry after you load this .yml as a dict
    'pos_N_scans'            : 16384, # type: int, unit: #. Number of probe positions (or equivalently diffraction patterns since 1 DP / position)
    'pos_N_scan_slow'        : 128, # type: int, unit: #. Number of scan position along slow scan direction. Usually it's the vertical direction of acquisition GUI
    'pos_N_scan_fast'        : 128, # type: int, unit: #. Number of scan position along fast scan direction. usually it's the horizontal direction of acquisition GUI
    'pos_scan_step_size'     : 0.4290, # type: float, unit: Ang. Step size between probe positions in a rectangular raster scan pattern
    'pos_scan_flipT'         : null, # type: null or list of 3 binary booleans (0 or 1) as [flipup, fliplr, transpose] just like PtychoShleves. Default value is null or equivalently [0,0,0]. This applies additional flip and transpose to initialized scan patterns. Note that modifing 'scan_flipT' would change the image orientation, so it's recommended to set this to null, and only use 'meas_flipT' to get the orientation correct
    'pos_scan_affine'        : null, # type: null or list of 4 floats as [scale, asymmetry, rotation, shear] just like PtychoShleves. Default is null or equivalently [1,0,0,0], rotation and shear are in unit of degree. This applies additional affine transformation to initialized scan patterns to correct sample drift and imperfect scan coils
    'pos_scan_rand_std'      : 0.15, # type: null or float, unit: px (real space). Randomize the initial guess of scan positions with Gaussian distributed displacement (std in px) to reduce raster grid pathology
    # Object
    'obj_source'             : 'simu', # type: str. Data source of the object. Currently supporting 'simu', 'PtyRAD', 'PtyShv', and 'custom'
    'obj_params'             : null, # type: null, list of 4 ints, str, or numpy array. Parameters of the object loading/initialization. For 'simu' (simulating object), provide a list of 4 ints (omode, Nz, Ny, Nx) to specify the object shape or null to let PtyRAD determine it (null is suggested and is consistent with how PtyShv creates their initial object). For loading object from 'PtyRAD' or 'PtyShv', provide a str of <PATH_TO_RECONSTRUCTION_FILE>. For 'custom' object source, pass the 4D numpy array to the 'obj_params' entry after you load this .yml as a dict
    'obj_slice_thickness'    : 6, # type: float, unit: Ang. Slice thickness for multislice ptychography. Typical values are between 1 to 20 Ang
    'obj_Nlayer'             : 2, # type: int, unit: #. Number of slices for multislice object
    'obj_omode_max'          : 1, # type: int, unit: #. Maximum number of mixed object modes. Set to omode_max = 1 for single object state, omode_max > 1 for mixed-state object during initialization. For simulated initial object, it'll be generated with the specified number of object modes. For loaded object, the omode dimension would be capped at this number
    'obj_omode_init_occu'    : {'occu_type': 'uniform', 'init_occu': null}, # type: dict. Occupancy type and value for mixed-object modes. Typically we do 'uniform' for frozen phonon like configurations as {'occu_type': 'uniform', 'init_occu': null}. 'occu_type' can be either 'uniform' or 'custom', if 'custom', pass in the desired occupancy as an array to 'init_occu'
    # Tilt
    'tilt_source'            : 'simu', # type: str. Data source of the object tilts. Currently supporting 'simu', 'PtyRAD', and 'custom'
    'tilt_params'            : {'tilt_type':'all', 'init_tilts':[[0,0]]}, # type: dict, str, or numpy array. Parameters of the object tilt loading/initialization. The object tilt is implemeted by tilted Fresnel propagator, which should be fairly accurate within 1 degree (17 mrad). For 'simu' (simulating object tilts), provide a dict as {'tilt_type':'all', 'init_tilts':[[tilt_y, tilt_x]]}. tilt_y and tilt_x are floats in unit of mrad, defaults are [[0,0]]. 'tilt_type' can be either 'all' or 'each'. 'tilt_type': 'all' will create a (1,2) tilt array specifying all positions has the same tilt as 'initial_tilts', this is a globally uniform object tilt that can be either fixed, hypertune optimized, or AD-optimized (if learning rate of 'obj_tilts' != 0). 'tilt_type': 'each' will create a (N_scans,2) tilt array that all position starts at the same 'init_tilts', but it can be later individually optimized through AD by setting learning rate of 'obj_tilts' != 0, which allows pos-dependent local object tilt correction. For loading object tilts from 'PtyRAD', provide a str of <PATH_TO_RECONSTRUCTION_FILE>. For 'custom' object tilts source, pass the (N_scans,2) or (1,2) numpy array to the 'tilt_params'. You should always provide an initial tilt guess for tilt correction either through hypertune or estimate with '/scripts/get_local_obj_tilts.ipynb' because optimizing tilts with AD from scratch would be too slow and most likely arrive at barely corrected, slice-shifted object
}
